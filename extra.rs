#![no_std]
#![no_main]

use cortex_m_rt::pre_init;
use embassy_sync::pubsub::PubSubChannel;
use core::arch::asm;
use defmt::*;
use embassy_executor::Spawner;
use embassy_stm32::bind_interrupts;
use embassy_stm32::time::Hertz;
use embassy_stm32::Config;
use embassy_stm32::gpio::{Output, Pull, Level, Speed, OutputType};
use embassy_stm32::interrupt;
use embassy_stm32::usart::{self, Uart};
use embassy_stm32::timer::simple_pwm::{PwmPin,SimplePwm};
use embassy_stm32::time::hz;
use embassy_stm32::exti::ExtiInput;
use embassy_time::Timer;
use embassy_sync::channel::Channel;
use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;
use core::sync::atomic::{AtomicBool, AtomicU8, Ordering};
use heapless::String;
use core::fmt::Write;
use {defmt_rtt as _, panic_probe as _};

static DUTY_CYCLE:AtomicU8=AtomicU8::new(0);
static SPIN_CLOCKWISE:AtomicBool=AtomicBool::new(true);

static BUTTON_CHANNEL:Channel<CriticalSectionRawMutex,&'static str,4>=Channel::new();
static DC_CHANNEL:PubSubChannel<CriticalSectionRawMutex,u8,4,2,1>=PubSubChannel::new();
static SD_CHANNEL:PubSubChannel<CriticalSectionRawMutex,&'static str,4,2,1>=PubSubChannel::new();

// Configura√ß√µes de mem√≥ria baseadas no memory.x
// const FLASH_ORIGIN: u32 = 0x08000000;
// const FLASH_LENGTH: u32 = 512 * 1024; // 512K

// const RAM_ORIGIN: u32 = 0x20000000;
// const RAM_LENGTH: u32 = 80 * 1024; // 80K

// const SRAM2_ORIGIN: u32 = 0x20014000;
// const SRAM2_LENGTH: u32 = 16 * 1024; // 16K

// const CCMRAM_ORIGIN: u32 = 0x10000000;
// const CCMRAM_LENGTH: u32 = 32 * 1024; // 32K

// S√≠mbolos do linker para obter informa√ß√µes de uso
// extern "C" {
//     static __sdata2: u32;
//     static __edata2: u32;
//     static __sidata2: u32;
//     static __sccmdata: u32;
//     static __eccmdata: u32;
//     static __siccmdata: u32;
//     static __sdata: u32;
//     static __edata: u32;
//     static __sbss: u32;
//     static __ebss: u32;
//     static __sstack: u32;
//     static __estack: u32;
// }

macro_rules! get {
    ($a:expr) => {
        $a.load(Ordering::Relaxed)
    };
}
macro_rules! post {
    ($a:expr,$b:expr) => {
        $a.store($b,Ordering::Relaxed)
    };
}

// #[derive(Clone, Copy)]
// struct MemoryInfo {
//     name: &'static str,
//     origin: u32,
//     total_size: u32,
//     used_size: u32,
// }

// impl MemoryInfo {
//     fn new(name: &'static str, origin: u32, total_size: u32, used_size: u32) -> Self {
//         Self {
//             name,
//             origin,
//             total_size,
//             used_size,
//         }
//     }

//     fn free_size(&self) -> u32 {
//         self.total_size.saturating_sub(self.used_size)
//     }

//     fn usage_percent(&self) -> u32 {
//         if self.total_size == 0 {
//             0
//         } else {
//             (self.used_size * 100) / self.total_size
//         }
//     }
// }

// // Fun√ß√£o para formatar tamanho em bytes
// fn format_size(size: u32) -> (u32, &'static str) {
//     if size >= 1024 * 1024 {
//         (size / (1024 * 1024), "MB")
//     } else if size >= 1024 {
//         (size / 1024, "KB")
//     } else {
//         (size, "B")
//     }
// }

// // Fun√ß√£o para calcular o uso de mem√≥ria
// fn calculate_memory_usage() -> [MemoryInfo; 4] {
//     unsafe {
//         // C√°lculo para RAM principal
//         let ram_data_size = (&__edata as *const u32 as u32) - (&__sdata as *const u32 as u32);
//         let ram_bss_size = (&__ebss as *const u32 as u32) - (&__sbss as *const u32 as u32);
//         let ram_stack_size = (&__estack as *const u32 as u32) - (&__sstack as *const u32 as u32);
//         let ram_used = ram_data_size + ram_bss_size + ram_stack_size;

//         // C√°lculo para SRAM2
//         let sram2_used = (&__edata2 as *const u32 as u32) - (&__sdata2 as *const u32 as u32);

//         // C√°lculo para CCMRAM
//         let ccmram_used = (&__eccmdata as *const u32 as u32) - (&__sccmdata as *const u32 as u32);

//         // FLASH usage (aproximado - c√≥digo + dados inicializados)
//         let flash_used = ram_data_size + sram2_used + ccmram_used + 32 * 1024; // Estimativa do c√≥digo

//         [
//             MemoryInfo::new("FLASH", FLASH_ORIGIN, FLASH_LENGTH, flash_used),
//             MemoryInfo::new("RAM", RAM_ORIGIN, RAM_LENGTH, ram_used),
//             MemoryInfo::new("SRAM2", SRAM2_ORIGIN, SRAM2_LENGTH, sram2_used),
//             MemoryInfo::new("CCMRAM", CCMRAM_ORIGIN, CCMRAM_LENGTH, ccmram_used),
//         ]
//     }
// }

// // Fun√ß√£o para gerar relat√≥rio de mem√≥ria
// fn generate_memory_report() -> String<2048> {
//     let memory_info = calculate_memory_usage();
//     let mut report = String::<2048>::new();
    
//     report.push_str("\r\n=== MEMORY USAGE REPORT ===\r\n").ok();
//     report.push_str("Generated by STM32 Memory Monitor\r\n\r\n").ok();
    
//     for mem in &memory_info {
//         let (total_val, total_unit) = format_size(mem.total_size);
//         let (used_val, used_unit) = format_size(mem.used_size);
//         let (free_val, free_unit) = format_size(mem.free_size());
        
//         // Nome da mem√≥ria
//         let mut line = String::<128>::new();
//         core::write!(line, "üìä {}: \r\n", mem.name).ok();
//         report.push_str(&line).ok();
        
//         // Informa√ß√µes de tamanho
//         line.clear();
//         core::write!(line, "  Total: {}{} | Used: {}{} | Free: {}{}\r\n", 
//                total_val, total_unit, used_val, used_unit, free_val, free_unit).ok();
//         report.push_str(&line).ok();
        
//         // Usage e endere√ßo
//         line.clear();
//         core::write!(line, "  Usage: {}% | Address: 0x{:08X}\r\n", 
//                mem.usage_percent(), mem.origin).ok();
//         report.push_str(&line).ok();
//     }
    
//     report.push_str("=========================\r\n").ok();
//     report.push_str("Commands: /heap, /help\r\n\r\n").ok();
    
//     report
// }

fn get_number(str: &[u8]) -> i8 {
    info!("get_number received {}",str);
    // Check for empty input
    if str.is_empty() {
        return -1;
    }
    // Trim leading/trailing whitespace
    let start = str.iter().position(|&b| b != b' ' && b != b'\t').unwrap_or(str.len());
    if start >= str.len() {
        return -1; // Only whitespace
    }
    
    let end = str.iter().rposition(|&b| b != b' ' && b != b'\t' && b != b'\r' && b != b'\n')
    .map(|i| i + 1)
    .unwrap_or(str.len());

if start >= end {
    return -1;
    }
    
    let trimmed = &str[start..end];
    
    if let Ok(number_str) = core::str::from_utf8(trimmed) {
        if let Ok(duty_value) = number_str.parse::<u8>() {
            if duty_value <= 100 {
                return duty_value as i8;
            }
        }
    }
    return -1;
}
fn process_command(line:&[u8],out:&mut String<256>)->i8{
    out.clear();
    let pos=line.iter().position(|&b| b==b' ').unwrap_or(line.len());
    let command=&line[..pos];
    if command==b"dutycycle"{
        if (pos+1)<line.len(){
        let dc=get_number(&line[pos+1..]);
        info!("duty value: {}",dc);
        if dc!=-1{
                return dc;
            }
            }
            out.push_str("invalid duty cycle value\r\n").ok();
    }
    else if command==b"status"{
        core::write!(out,"spin: {}\r\nduty cycle: {}%\r\n",if get!(SPIN_CLOCKWISE) {"clockwise"} else {"counterclockwise"},get!(DUTY_CYCLE   )).unwrap();
    }
    else if command==b"help"{
        out.push_str("====== Command List ======\r\ndutycycle <number> - Change the duty cycle of the motor's PWM\r\nstatus - Show the current spin direction and duty cycle of the motor\r\nhelp - Show this help guide\r\ntasks - Show list of tasks installed\r\n").ok();
    }
    else if command==b"tasks"{
        out.push_str("====== Task List ======\r\nbutton_task - Deals with the press of the button\r\npwm_task1 - Manages the pwm for the clock spin of the motor\r\npwm_task2 - Manages the pwm for the counterclock spin of the motor\r\nuart_task - Sends and receives serial messages via UART\r\n").ok();
    }
    else{
        out.push_str("Unknown command\r\n").ok();
    }
    return -1;
}
// Declare async tasks
#[embassy_executor::task]
async fn button_task(mut button: ExtiInput<'static>) {
    //Task to deal with button press, changes the spin direction of the motor
    let publisher=SD_CHANNEL.publisher().unwrap();
    loop {
        button.wait_for_rising_edge().await;
        button.wait_for_falling_edge().await;
        BUTTON_CHANNEL.send("Button pressed!\n\r").await;
        publisher.publish("change").await;
        let current=get!(SPIN_CLOCKWISE);
        post!(SPIN_CLOCKWISE,!current);
    }
}

//Declare async tasks
#[embassy_executor::task]
async fn pwm_task1(mut pwm: SimplePwm<'static, embassy_stm32::peripherals::TIM3>) {
    //Task to generate the pwm to control de motor, 1khz on TIM3 CH1, PA6
    let mut sd_handler=SD_CHANNEL.subscriber().unwrap();
    let mut dc_handler=DC_CHANNEL.subscriber().unwrap();
    let mut is_active=true;

    pwm.set_frequency(hz(1000));
    
    let mut ch1=pwm.ch1();
    ch1.set_duty_cycle_percent(0);
    
    // Enable PWM
    ch1.enable();
    
    loop {
        match embassy_futures::select::select(
            sd_handler.next_message(),
            dc_handler.next_message()
        ).await {
            embassy_futures::select::Either::First(_) => {
        is_active=!is_active;
        if is_active{            
            Timer::after_millis(1000).await;
            ch1.set_duty_cycle_percent(get!(DUTY_CYCLE));
        }
        else{
            ch1.set_duty_cycle_fully_off();
        }
    }
    embassy_futures::select::Either::Second(dc) => {
        if let embassy_sync::pubsub::WaitResult::Message(duty_cycle) = dc {
            if is_active {
                info!("setting duty cycle to {}",duty_cycle);
                ch1.set_duty_cycle_percent(duty_cycle);
            }
        }
    }
        // Increase duty cycle from 10% to 90%
        // for duty_percent in 10..=90 {
        //     ch1.set_duty_cycle_percent(duty_percent);
        //     Timer::after_millis(50).await;
        // }
        
        // // Decrease duty cycle from 90% to 10%
        // for duty_percent in (10..=90).rev() {
        //     ch1.set_duty_cycle_percent(duty_percent);
        //     Timer::after_millis(50).await;
        // }
    }
}
}

//Declare async tasks
#[embassy_executor::task]
async fn pwm_task2(mut pwm: SimplePwm<'static, embassy_stm32::peripherals::TIM4>) {
    //Task to generate the pwm to control de motor, 1khz on TIM4 CH1, PB6     
    let mut sd_handler=SD_CHANNEL.subscriber().unwrap();
    let mut dc_handler=DC_CHANNEL.subscriber().unwrap();
    let mut is_active=false;  
    pwm.set_frequency(hz(1000));
    let mut ch1=pwm.ch1();
    ch1.set_duty_cycle_percent(0);
    
    // Enable PWM
    ch1.enable();
    
    // Step through different duty cycles
    // let duty_cycles = [10, 25, 50, 75, 90];
    // let mut duty_index = 0;
    
    loop {
        match embassy_futures::select::select(
            sd_handler.next_message(),
            dc_handler.next_message()
        ).await {
            embassy_futures::select::Either::First(_) => {
        is_active=!is_active;
        if is_active{            
            Timer::after_millis(1000).await;
            ch1.set_duty_cycle_percent(get!(DUTY_CYCLE));
        }
        else{
            ch1.set_duty_cycle_fully_off();
        }
    }
    embassy_futures::select::Either::Second(dc) => {
        if let embassy_sync::pubsub::WaitResult::Message(duty_cycle) = dc {
            if is_active {
                info!("setting duty cycle to {}",duty_cycle);
                ch1.set_duty_cycle_percent(duty_cycle);
            }
        }
    }
    }
        // let duty_percent = duty_cycles[duty_index];
        // ch1.set_duty_cycle_percent(duty_percent);
                
        // duty_index = (duty_index + 1) % duty_cycles.len();
        // Timer::after_millis(1000).await;
    }
}

// Declare async tasks
#[embassy_executor::task]
async fn uart_task(mut lpuart: Uart<'static, embassy_stm32::mode::Async>) {
    lpuart.write("UART started, type help to see command list...\r\n".as_bytes()).await.unwrap();
    let mut read_buffer = [0u8; 1];     // Single byte for reading
    let mut line_buffer = [0u8; 128];   // Line accumulation buffer
    let mut line_pos = 0;               // Current position in line buffer
    
    let publisher=DC_CHANNEL.publisher().unwrap();
    let mut s:String<6>=String::new();
    let mut output:String<256>=String::new();
    let header=b"<control>:";
    lpuart.write(header).await.unwrap();
    let mut rt:i8;
    
    // Loop to handle both UART echo and button messages
    loop {
        // Use select to handle both UART input and button messages
        match embassy_futures::select::select(
            lpuart.read(&mut read_buffer),
            BUTTON_CHANNEL.receive()
        ).await {
            embassy_futures::select::Either::First(_) => {
                // Handle UART input
                let byte = read_buffer[0];
                
                // Check for Enter key (carriage return \r or newline \n)
                if byte == b'\r' || byte == b'\n' {
                    output.clear();
                    // Enter was pressed - process the complete line
                    if line_pos > 0 {
                        // Echo newline
                        lpuart.write(b"\r\n").await.unwrap();
                        
                        // Process the complete line here
                        let line = &line_buffer[..line_pos];
                        rt=process_command(line, &mut output);
                        if rt!=-1{
                            post!(DUTY_CYCLE,rt as u8);
                            publisher.publish(rt as u8).await;
                        }
                        if !output.is_empty(){
                            lpuart.write(output.as_bytes()).await.unwrap();
                        }
                        lpuart.write(header).await.unwrap();
                        
                        // Example: echo back the complete line with a prefix

                        // if line.starts_with(b"dutycycle"){
                        //     let remaining=&line[10..];
                        //     if remaining.len()>0{
                        //         if let Ok(number_str)=core::str::from_utf8(remaining){
                        //             if let Ok(duty_value)=number_str.parse::<u8>(){
                        //                 if duty_value<=100{
                        //                     post!(DUTY_CYCLE,duty_value);
                        //                     publisher.publish(duty_value).await;
                        //                 }else{
                        //                     lpuart.write(b"Error: Duty cycle must be 0-100\r\n").await.unwrap();
                        //                 }
                        //             }else{
                        //                 lpuart.write(b"Error: Invalid number format\r\n").await.unwrap();
                        //             }
                        //         }else {
                        //             lpuart.write(b"Error: Invalid characters\r\n").await.unwrap();
                        //         }
                        //     }else {
                        //         lpuart.write(b"Error: No number after dutycycle\r\n").await.unwrap();
                        //     }
                        // }
                        // else if line.starts_with(b"status") {
                        //     if get!(SPIN_CLOCKWISE){
                        //         lpuart.write("spin: clockwise\r\n".as_bytes()).await.unwrap();
                        //     }
                        //     else{
                        //         lpuart.write("spin: counterclockwise\r\n".as_bytes()).await.unwrap();
                        //     }
                        //     lpuart.write(b"duty cycle: ").await.unwrap();
                        //     s.clear();
                        //     core::write!(s,"{}%\r\n",get!(DUTY_CYCLE)).unwrap();
                        //     lpuart.write(s.as_bytes()).await.unwrap();
                        // }
                        // else if line.starts_with(b"help"){
                        //     lpuart.write("====== Command List ======\r\ndutycycle <number> - Change the duty cycle of the motor's PWM\r\nstatus - Show the current spin direction and duty cycle of the motor\r\nhelp - Show this help guide\r\ntasks - Show list of tasks installed\r\n".as_bytes()).await.unwrap();
                        // }
                        // else if line.starts_with(b"tasks"){
                        //     lpuart.write("====== Task List ======\r\nbutton_task - Deals with the press of the button\r\npwm_task1 - Manages the pwm for the clock spin of the motor\r\npwm_task2 - Manages the pwm for the counterclock spin of the motor\r\nuart_task - Sends and receives serial messages via UART\r\n".as_bytes()).await.unwrap();
                        // }
                        // else if line.starts_with(b"heap"){
                        //     // lpuart.write(generate_memory_report().as_bytes()).await.unwrap();
                        // }
                        // else{
                        //     lpuart.write(b"unknown command\r\n").await.unwrap();
                        // }
                        // lpuart.write(header).await.unwrap();
                        
                        // Reset line buffer for next line
                        line_pos = 0;
                    } else {
                        // Just echo newline if empty line
                        lpuart.write(b"\r\n").await.unwrap();
                    }
                } else if byte == 8 || byte == 127 { // Backspace or DEL
                    if line_pos > 0 {
                        line_pos -= 1;
                        // Echo backspace sequence to terminal
                        lpuart.write(b"\x08 \x08").await.unwrap();
                    }
                } else if byte >= 32 && byte <= 126 { // Printable ASCII characters
                    // Add character to line buffer if there's space
                    if line_pos < line_buffer.len() {
                        line_buffer[line_pos] = byte;
                        line_pos += 1;
                        
                        // Echo the character
                        lpuart.write(&read_buffer).await.unwrap();
                    }
                }
                // Ignore other control characters
            }
            embassy_futures::select::Either::Second(msg) => {
                // Handle button messages
                lpuart.write(msg.as_bytes()).await.unwrap();
                lpuart.write(b"\r\n").await.unwrap();
                lpuart.write(header).await.unwrap();
                line_pos=0;
            }
        }
    }
}

bind_interrupts!(struct Irqs {
    LPUART1 => embassy_stm32::usart::InterruptHandler<embassy_stm32::peripherals::LPUART1>;
});

#[pre_init]
unsafe fn before_main() {
    unsafe {
        asm!{
            "ldr r0, =__sccmdata
            ldr r1, =__eccmdata
            ldr r2, =__siccmdata
            0:
            cmp r1, r0
            beq 1f
            ldm r2!, {{r3}}
            stm r0!, {{r3}}
            b 0b
            1:"
        }

        asm!{
            "ldr r0, =__sdata2
            ldr r1, =__edata2
            ldr r2, =__sidata2
            2:
            cmp r1, r0
            beq 3f
            ldm r2!, {{r3}}
            stm r0!, {{r3}}
            b 2b
            3:"
        }
    }
}

#[interrupt]
unsafe fn TIM3(){
    
    // reset interrupt flag
    //unsafe {
    //    let pin = embassy_stm32::peripherals::PA5::steal();
    //    let mut pin = Output::new(pin, Level::High, Speed::Low);
    //    pin.set_high();
    //}
    //pac::TIM3.sr().modify(|r| r.set_uif(false));
    info!("interrupt happens: tim20");
}


#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let mut config = Config::default();
    {
        use embassy_stm32::rcc::*;
        config.rcc.hse = Some(Hse {
            freq: Hertz(24_000_000),
            mode: HseMode::Oscillator,
        });
        config.rcc.pll = Some(Pll {
            source: PllSource::HSE,
            prediv: PllPreDiv::DIV6,
            mul: PllMul::MUL85,
            divp: None,
            divq: None,
            // Main system clock at 170 MHz
            divr: Some(PllRDiv::DIV2),
        });
        config.rcc.sys = Sysclk::PLL1_R;

        config.rcc.mux.adc12sel = mux::Adcsel::SYS;
        config.rcc.ahb_pre = AHBPrescaler::DIV1;
        config.rcc.apb1_pre = APBPrescaler::DIV1;
        config.rcc.apb2_pre = APBPrescaler::DIV1;
    }

    let p: embassy_stm32::Peripherals = embassy_stm32::init(config);

    //Creation of the button task
    let button = ExtiInput::new(p.PC13, p.EXTI13, Pull::Down);
    spawner.spawn(button_task(button)).unwrap();

    //Creation of the UART task
    let mut config = usart::Config::default();
    config.baudrate = 115_200;
    let lpusart = Uart::new(p.LPUART1, p.PA3, p.PA2, Irqs, p.DMA1_CH1, p.DMA1_CH2, config).unwrap();
    spawner.spawn(uart_task(lpusart)).unwrap();

    //Creation of the first PWM task
    let pwm_channel=PwmPin::new_ch1(p.PA6,OutputType::PushPull);
    let pwm1 = SimplePwm::new(p.TIM3,
        Some(pwm_channel),
        None,
        None,
        None,
        hz(1000),
        Default::default());
    spawner.spawn(pwm_task1(pwm1)).unwrap();

    //Creation of the second PWM task
    let pwm_channel2=PwmPin::new_ch1(p.PB6,OutputType::PushPull);
    let pwm2 = SimplePwm::new(p.TIM4,
     Some(pwm_channel2),
     None,
     None,
     None,
     hz(1000),
     Default::default());
    spawner.spawn(pwm_task2(pwm2)).unwrap();

    let mut led = Output::new(p.PA5, Level::High, Speed::Low);

    loop {
        led.set_high();
        Timer::after_millis(100).await;

        led.set_low();
        Timer::after_millis(100).await;
    }
}